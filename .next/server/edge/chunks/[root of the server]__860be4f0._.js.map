{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { auth } from '@/lib/firebase-admin'; // We'll need firebase-admin for server-side auth checks\n\n// Initialize Firebase Admin SDK if not already initialized\n// This would typically be done in a separate firebase-admin.ts setup file\n// For simplicity, we'll include a basic check here.\n// In a real app, ensure this is properly initialized.\n// See: https://firebase.google.com/docs/admin/setup\n\n// Placeholder for firebase-admin initialization.\n// You'll need to set up a service account and environment variables.\n// e.g., GOOGLE_APPLICATION_CREDENTIALS\n\n/*\n// src/lib/firebase-admin.ts\nimport * as admin from 'firebase-admin';\n\nif (!admin.apps.length) {\n  admin.initializeApp({\n    credential: admin.credential.cert({\n      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n      privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\\\n/g, '\\n'),\n    }),\n  });\n}\nexport const authAdmin = admin.auth();\nexport const dbAdmin = admin.firestore();\n*/\n\n// This is a simplified middleware. For robust server-side auth with Firebase,\n// you'd typically use firebase-admin SDK to verify ID tokens.\n// However, client-side checks in useAuth and page components also provide protection.\n// This middleware primarily handles redirects for unauthenticated access to /admin.\n\nexport async function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n  const sessionCookie = request.cookies.get('__session')?.value; // Example cookie name, adjust as per your auth strategy\n\n  if (pathname.startsWith('/admin')) {\n    if (!sessionCookie) {\n      // No session cookie, redirect to login\n      // In a real scenario with server-verified sessions, this check is more robust.\n      // For client-side rendering heavy apps, the client handles redirect after checking auth state.\n      // This middleware acts as an initial gatekeeper.\n      // A more complete solution would involve verifying the sessionCookie with Firebase Admin SDK.\n      // For now, we'll rely on client-side auth checks within the /admin pages and AuthProvider.\n      // The AuthProvider will redirect if not admin. This middleware is a basic guard.\n      // This is a placeholder: a true server-side check of the token is needed here.\n      // For this example, we'll assume that if the /admin route is hit,\n      // the client-side AuthProvider will handle the role check and redirect if necessary.\n      // If you want strict server-side protection, you must verify the token.\n      // The below is illustrative of what you might do if you had a server-side token verification.\n      // For now, we'll let the client-side routing handle this based on AuthContext.\n      // return NextResponse.redirect(new URL('/auth/login?redirect=/admin', request.url));\n    }\n    // If sessionCookie exists, ideally verify it here using Firebase Admin SDK.\n    // If token is invalid or user is not admin, redirect.\n    // Example (pseudo-code, requires firebase-admin):\n    // try {\n    //   const decodedToken = await authAdmin.verifyIdToken(sessionCookie);\n    //   const userDoc = await dbAdmin.collection('users').doc(decodedToken.uid).get();\n    //   if (!userDoc.exists || userDoc.data()?.role !== 'admin') {\n    //     return NextResponse.redirect(new URL('/', request.url)); // Or an unauthorized page\n    //   }\n    // } catch (error) {\n    //   return NextResponse.redirect(new URL('/auth/login?redirect=' + pathname, request.url));\n    // }\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/admin/:path*'],\n};\n\n// Note: For full server-side protection, you'd need to:\n// 1. Set up Firebase Admin SDK (requires service account credentials).\n// 2. When a user logs in, create a session cookie (HttpOnly, Secure) via a backend function/API route.\n// 3. In middleware, verify this session cookie.\n// The current setup relies more on client-side checks via AuthProvider for role enforcement\n// once the user reaches the /admin path.\n"],"names":[],"mappings":";;;;AACA;AAAA;;AAoCO,eAAe,WAAW,OAAoB;IACnD,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IACpC,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC,cAAc,OAAO,wDAAwD;IAEvH,IAAI,SAAS,UAAU,CAAC,WAAW;QACjC,IAAI,CAAC,eAAe;QAClB,uCAAuC;QACvC,+EAA+E;QAC/E,+FAA+F;QAC/F,iDAAiD;QACjD,8FAA8F;QAC9F,2FAA2F;QAC3F,iFAAiF;QACjF,+EAA+E;QAC/E,kEAAkE;QAClE,qFAAqF;QACrF,wEAAwE;QACxE,8FAA8F;QAC9F,+EAA+E;QAC/E,qFAAqF;QACvF;IACA,4EAA4E;IAC5E,sDAAsD;IACtD,kDAAkD;IAClD,QAAQ;IACR,uEAAuE;IACvE,mFAAmF;IACnF,+DAA+D;IAC/D,0FAA0F;IAC1F,MAAM;IACN,oBAAoB;IACpB,4FAA4F;IAC5F,IAAI;IACN;IAEA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QAAC;KAAgB;AAC5B,GAEA,wDAAwD;CACxD,uEAAuE;CACvE,uGAAuG;CACvG,gDAAgD;CAChD,4FAA4F;CAC5F,yCAAyC"}}]
}